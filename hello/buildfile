libs =
#import libs += libhello%lib{hello}

exe{hello}: {hxx ixx txx cxx}{** -stdafx} liba{stdafx} $libs

cxx.poptions =+ "-I$src_root" "-I$src_base"

# Rule to compile the C++ Standard Library headers into a more efficient
# intermediate form.
#
# Note that until issues with C++ modules are adequately addressed, they remain
# more of a theoretical curiosity than a practical solution, so PCH remains the
# pragmatic choice.
#
# https://github.com/build2/build2/issues/5
#
<file{stdafx.pch} obja{stdafx.obj}>: cxx{stdafx} hxx{stdafx}
{{
  s = $path($<[0])
  p = $path($>[0])
  o = $path($>[1])

  # /EHsc and /utf-8 are intrinsic to build2 and, as such, are not
  # affected by our build configuration.
  #
  sys_hdr = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')
  sys_pch = /nologo /EHsc /utf-8 /c /TP /Yc "/Fp$p" "/Fo$o"

  # Unlike above, here we rely on our build configuration to propagate runtime
  # and essential flags (config.cc.poptions, config.cc.coptions). Failing to do
  # so may not directly cause build failures, but it can give rise to unexpected
  # problems.
  #
  poptions = $cxx.poptions $config.cc.poptions $sys_hdr
  coptions = $cxx.coptions $config.cc.coptions $sys_pch

  diag c++ ($<[0])

  $cxx.path $poptions $coptions $cxx.mode $s
}}


[rule_hint=cxx] liba{stdafx}: file{stdafx.pch}:
{
  # Inform target(s) that we will manually handle prerequisites.
  #
  include = adhoc

  # Build PCH prior to any source that relies on it.
  #
  update = match
}

[rule_hint=cxx] liba{stdafx}: obja{stdafx}
{
  # Export compiler flags necessary for target(s) to consume the PCH.
  #
  cxx.export.poptions += "/Yustdafx.hxx" "/FIstdafx.hxx" "/Fp$out_base/stdafx"

  # Prevent unintended distribution.
  #
  install = false
}

# Here we need to make stdafx.hxx accessible in out_root for build2's input file
# preprocessing module, as the generated source will not be located within our
# source tree.
#
# @@ should we use <> with /Fi instead, and if so, what are the implications?
#
if ($src_root != $out_root)
{
  hxx{stdafx}:
  {{
    s = $src_base/$name($>).hxx
    o = $out_base/$name($>).hxx

    diag cp $>

    cp $s $o
  }}
}

# When cc.reprocess is true, __build2_preprocess is defined during dependency
# extraction. This is used to work around separate preprocessing bugs in the
# compiler (one area where this is particularly evident is during PCH
# compilation).
#
obj{*}: cc.reprocess = true
